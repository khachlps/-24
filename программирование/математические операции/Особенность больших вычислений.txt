Для сложения и вычитания по умолчанию используется ячейка 4 байта (long), но для умножения и деления - 2 байта (int). Если при умножении или делении в текущем действии результат превысит 32768 - ячейка переполнится и мы получим некорректный результат. 
Для исправления ситуации нужно привести тип переменной к long перед вычислением, что заставит МК выделить дополнительную память. Например  a = (long)b * c;

Для цифр существуют модификаторы, делающие то же самое:
	U или u - перевод в uint16_t (от 0 до 65'535). Пример: 36000u
	L или l - перевод в int32_t (-2 147 483 648… 2 147 483 647). Пример: 325646L
	UL или ul - перевод в uint32_t (от 0 до 4 294 967 295). Пример: 361341ul
Посмотрим, как это работает на практике:
	long val;
	val = 2000000000 + 6000000;         // посчитает корректно (т.к. сложение)
	val = 25 * 1000;                    // посчитает корректно (умножение, меньше 32'768)
	val = 35 * 1000;                    // посчитает НЕКОРРЕКТНО! (умножение, больше 32'768)
	val = (long)35 * 1000;              // посчитает корректно (выделяем память (long) )
	val = 35 * 1000L;                   // посчитает корректно (модификатор L)
	val = 35 * 1000u;                   // посчитает корректно (модификатор u)
	val = 70 * 1000u;                   // посчитает НЕКОРРЕКТНО (модификатор u, результат > 65535)
	val = 1000 + 35 * 10 * 100;         // посчитает НЕКОРРЕКТНО! (в умножении больше 32'768)
	val = 1000 + 35 * 10 * 100L;        // посчитает корректно! (модификатор L)
	val = (long)35 * 1000 + 35 * 1000;  // посчитает НЕКОРРЕКТНО! Второе умножение всё портит
	val = (long)35 * 1000 + (long)35 * 1000;  // посчитает корректно (выделяем память (long) )
	val = 35 * 1000L + 35 * 1000L;      // посчитает корректно (модификатор L)